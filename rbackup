#!/usr/bin/env python

import sys
import os
import subprocess
import getopt

#######################
# rsync command classes
#######################

class RsyncCommand(object):
    commandName = 'rsync'
    baseArgs = ['--archive', '--itemize-changes', '-vv']

    def __init__(self, src, dest, args=None):
        if args is None:
            args = []
        self._src = src
        self._dest = dest
        self._args = args

        if not self._src.endswith('/'):
            self._src += '/'

        self._handler = NullOutputHandler()

    def setOutputHandler(self, handler):
        self._handler = handler

    def addArgs(self, args):
        if isinstance(args, basestring):
            args = [args]
        self._args.extend(args)

    def run(self):
        args = [self.commandName] + self.baseArgs + self._extraArgs()
        args.extend(self._args)
        args.extend([self._src, self._dest])

        self._handler.log('rsync command: %s' % args)
        proc = subprocess.Popen(args, stdout=subprocess.PIPE,
                                stderr=subprocess.STDOUT)
        for line in proc.stdout:
            self._handler.rsyncLine(line)

        proc.wait()
        return proc.returncode

    # Overridable
    def _extraArgs(self):
        return []

class RsyncBackup(RsyncCommand):
    def __init__(self, src, dest, link=None, args=None):
        RsyncCommand.__init__(self, src, dest, args)
        self._link = link

    def _extraArgs(self):
        if self._link is None:
            return []
        else:
            return ['--link-dest=%s' % self._link]

class RsyncVerify(RsyncCommand):
    def _extraArgs(self):
        return ['--dry-run', '--checksum']

#################
# Output handlers
#################

class OutputHandler(object):
    def rsyncLine(self, line):
        raise NotImplementedError()

    def log(self, mesg):
        raise NotImplementedError()

    def close(self):
        pass

class NullOutputHandler(OutputHandler):
    def rsyncLine(self, line):
        pass

    def log(self, mesg):
        pass

class SequenceOutputHandler(OutputHandler):
    def __init__(self, handlers=None):
        if handlers is None:
            handlers = []
        self._handlers = handlers

    def addHandler(self, handler):
        self._handlers.append(handler)

    def rsyncLine(self, line):
        for handler in self._handlers:
            handler.rsyncLine(line)

    def log(self, mesg):
        for handler in self._handlers:
            handler.log(mesg)

    def close(self):
        for handler in self._handlers:
            handler.close()

class StreamOutputHandler(OutputHandler):
    def __init__(self, stream=sys.stdout, close=False):
        self._stream = stream
        self._close = close

    def rsyncLine(self, line):
        self._stream.write(line)

    def log(self, mesg):
        self._stream.write(mesg + '\n')

    def close(self):
        if self._close:
            self._stream.close()

class FileOutputHandler(StreamOutputHandler):
    def __init__(self, filename, mode='w'):
        StreamOutputHandler.__init__(self, open(filename, mode), close=True)
        self._filename = filename
        self._mode = mode

class Configuration(object):
    defaultConfig = {
        'LOG_DIR'     : None,
        'EXCLUDES'    : [],
        'RSYNC_OPTS'  : [],
        'BACKUP_OPTS' : [],
        'VERIFY_OPTS' : [],
    }

    requiredFields = ['SOURCE', 'BACKUP_POOL']

    def __init__(self, filename):
        self._conf = dict(self.defaultConfig)
        userConf = {}
        execfile(filename, userConf)
        self._conf.update(userConf)
        self._check()

    def _check(self):
        'Make sure required fields are present'
        missing = []
        for field in self.requiredFields:
            if field not in self._conf:
                missing.append(field)

        if missing:
            raise ValueError('Missing required configuration items: %r' %
                             missing)

    def __getattr__(self, name):
        if name in self._conf:
            return self._conf[name]

        raise AttributeError(name)

class Record(object):
    def __init__(self, filename):
        self._filename = filename
        self.last_backup = None

        try:
            f = open(self._filename, 'r')
            self.last_backup = f.read().strip()
            f.close()
        except IOError:
            pass

    def write(self):
        f = open(self._filename, 'w')
        print >> f, self.last_backup
        f.close()

def backup_name():
    import time
    return time.strftime('%Y-%m-%d_%H:%M:%S')

def main(args=None):
    if args is None:
        args = sys.argv[1:]

    try:
        (opts, arguments) = getopt.getopt(args, 'n', ['config=', 'rsync-opts=',
                                          'verify', 'dry-run', 'previous='])
    except getopt.GetoptError, e:
        raise # XXX Do something smarter later

    if arguments:
        print >> sys.stderr, 'Unexpected arguments: %r' % arguments
        return 2

    config_dir = os.path.expanduser('~/.rbackup')
    rsync_opts = []
    verify = False
    dry_run = False
    previous = None

    for (opt, val) in opts:
        if opt == '--config':
            config_dir = val
        elif opt == '--rsync-opts':
            rsync_opts.extend(val.split())
        elif opt == '--verify':
            verify = True
        elif opt in ('-n', '--dry-run'):
            dry_run = True
        elif opt == '--previous':
            previous = val

    config = Configuration(os.path.join(config_dir, 'rbackup.conf'))
    record = Record(os.path.join(config_dir, 'rbackup.last_backup'))
    new_name = backup_name()

    if verify:
        if previous is not None:
            target = previous
        elif record.last_backup is not None:
            target = os.path.join(config.BACKUP_POOL, record.last_backup)
        else:
            print >> sys.stderr, 'No last backup to verify!'
            return 1
        command = RsyncVerify(config.SOURCE, target)
    else:
        # XXX This works, but --previous is confusing. In combination with
        # --verify, or as an absolute path, it is straight-forward, but
        # otherwise it is relative to the target dir, which is weird.
        if previous is None and record.last_backup is not None:
            previous = os.path.join('..', record.last_backup)
        target = os.path.join(config.BACKUP_POOL, new_name)
        command = RsyncBackup(config.SOURCE, target, previous)

    if dry_run:
        command.addArgs('--dry-run')
    if config.EXCLUDES:
        command.addArgs(['--exclude=%s' % exc for exc in config.EXCLUDES])
    # Add options from config file and command line, in that order.
    command.addArgs(config.RSYNC_OPTS)
    if verify:
        command.addArgs(config.VERIFY_OPTS)
    else:
        command.addArgs(config.BACKUP_OPTS)
    command.addArgs(rsync_opts)

    handler = SequenceOutputHandler()
    handler.addHandler(StreamOutputHandler())
    if config.LOG_DIR:
        name = os.path.join(config.LOG_DIR, '%s.log' % new_name)
        handler.addHandler(FileOutputHandler(name))
    command.setOutputHandler(handler)

    result = command.run()
    if result is None:
        handler.log("rsync didn't exit??")
        result = 1
    elif result > 0:
        handler.log('rsync error: %d' % result)
    elif result < 0:
        handler.log('rsync exited with signal %d' % -result)
        result = 1

    handler.close()

    if not verify and not dry_run:
        record.last_backup = new_name
        record.write()

    return result

if __name__ == '__main__':
    sys.exit(main())
